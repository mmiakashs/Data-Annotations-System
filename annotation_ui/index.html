<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Data annotation tool for CRL Research</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }

      #doodle {
        position: relative;
        width: 0px;
        height: 0px;
        z-index: 2;
      }

      #canvas {
        z-index: 1;
      }

      .bbox {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }

      .handle, .ui-resizable-handle {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        border: 1px solid rgba(255, 0, 0, .5);
        background-color: rgba(255, 255, 0, .05);
        position: absolute;
      }

      .center-drag {
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: move;
      }

      .ui-resizable-n {
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: n-resize;
      }

      .ui-resizable-s {
        left: 50%;
        bottom: 0%;
        transform: translate(-50%, 50%);
        cursor: s-resize;
      }

      .ui-resizable-w {
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: w-resize;
      }

      .ui-resizable-e {
        right: 0%;
        top: 50%;
        transform: translate(50%, -50%);
        cursor: e-resize;
      }

      .ui-slider {
        position: relative;
        text-align: left;
        height: .8em;
      }

      .ui-slider-handle {
        position: absolute;
        z-index: 2;
        width: 1.2em;
        height: 1.2em;
        cursor: default;
        -ms-touch-action: none;
        touch-action: none;
        top: -.3em;
        margin-left: -.6em;
      }

      .ui-widget.ui-widget-content {
        border: 1px solid #d3d3d3;
      }

      .ui-state-default {
        border: 1px solid #d3d3d3;
        background-color: #e6e6e6;
      }

      .ui-state-hover, .ui-state-focus {
        border: 1px solid #999999;
        background-color: #dadada;
      }

      .ui-state-active {
        border: 1px solid #aaaaaa;
        background-color: #ffffff;
      }

      .ui-state-disabled {
        opacity: .35;
      }

      .ui-corner-all {
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>Data annotation tool for CRL Research</h1>
    <ol>
      <li>
        <p>This is a heavily simpilfied fork of the original <a href="https://github.com/dbolkensteyn/vatic.js">vatic.js</a> and should only be used for CRL research.</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>Upload the transcriptions JSON file that was generated by preprocess.py: <input type="file" id="transcriptionsFile" accept=".json" /></p>
      </li>
      <li>
        <p>If the video's frames have already been extracted, you should annotate using that. Upload a zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Optional: Load an existing JSON annotation file: <input type="file" id="jsonFile" accept=".json" disabled="true" /></p>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <p>Each video has two bounding boxes: The target bounding box and the reference bounding box. To create or update the target bounding box, first click 't', and then left click on two locations in the video corresopnding to the corners of the box. For the reference bounding box, click 'r'</p>
        <p>Make sure to make any manual corrections to the transcription of the video.</p>
        <p>You can also optionally specify a spacial relationship between the target and reference object.</p>
        <p>Tip: Use the spacebar to play/pause the video, and the left and right arrows to navigate frame by frame.</p>
        <div id="doodle">
          <canvas id="canvas"></canvas>
        </div>
        <p><input type="button" id="play" value="Play" disabled="true" /><input type="button" id="pause" value="Pause" disabled="true" style="display: none;" /></p>
        <div id="slider"></div>
        <p><label for="speed">Speed multiplier: </label><input type="text" id="speed" value="1.00" size="4" /></p>
        <div id="objects"></div>
        <div hidden=false id="spacialRelationshipDiv">
          <label><b>Spacial Relationship:  </b></label>
          <input type="text" id="spacialRelationship"/>
        </div>
        <div hidden=false id="transcriptionDiv">
          <label style="display: flex"><b>Transcription:  </b></label>
          <textarea rows="5" cols="80" id="transcription"></textarea>
        </div>
      </li>
      <li>
        <p><input type="button" id="generateJSON" value="Generate" disabled="true" /> the JSON annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="dist/nudged.js"></script>
    <script type="text/javascript" src="dist/pouchdb.min.js"></script>
    <script type="text/javascript" src="dist/jquery-1.12.4.js"></script>
    <script type="text/javascript" src="dist/jquery-ui.js"></script>
    <script type="text/javascript" src="helpers.js"></script>
    <script type="text/javascript" src="frames_handler.js"></script>
    <script type="text/javascript">
      "use strict";

      let config = {
        // Should be higher than real FPS to not skip real frames
        // Hardcoded due to JS limitations
        fps: 30,

        // Low rate decreases the chance of losing frames with poor browser performances
        playbackRate: 0.4,

        // Format of the extracted frames
        imageMimeType: 'image/jpeg',
        imageExtension: '.jpg',
      };

      let doodle = document.querySelector('#doodle');
      let canvas = document.querySelector('#canvas');
      let ctx = canvas.getContext('2d');
      let transcriptionsFile = document.querySelector("#transcriptionsFile");
      let zipFile = document.querySelector('#zipFile');
      let jsonFile = document.querySelector('#jsonFile');
      let videoDimensionsElement = document.querySelector('#videoDimensions');
      let extractionProgressElement = document.querySelector('#extractionProgress');
      let playButton = document.querySelector('#play');
      let pauseButton = document.querySelector('#pause');
      let speedInput = document.querySelector('#speed');
      let sliderElement = document.querySelector('#slider');
      let generateJSONButton = document.querySelector('#generateJSON');
      let spacialRelationshipDiv = document.querySelector('#spacialRelationshipDiv');
      let spacialRelationshipInput = document.querySelector('#spacialRelationship');
      let transcriptionDiv = document.querySelector('#transcriptionDiv');
      let transcriptionInput = document.querySelector('#transcription');

      let framesManager = new FramesManager();
      let annotatedObjectsTracker = new AnnotatedObjectsTracker(framesManager);
      let controlOrShiftPressed = false;
      let mouseIsOnDoodle = false;

      // Contains the default transcriptions of each video. These can be manually changed by the user in the annotation tool.
      let transcriptionMap = new Map();

      transcriptionsFile.addEventListener('change', updateTranscriptionMap, false);
      zipFile.addEventListener('change', extractionFileUploaded, false);
      jsonFile.addEventListener('change', importJSON, false);
      playButton.addEventListener('click', playClicked, false);
      pauseButton.addEventListener('click', pauseClicked, false);
      generateJSONButton.addEventListener('click', generateJSON, false);

      let slider = {
        init: function(min, max, onChange) {
          $(sliderElement).slider('option', 'min', min);
          $(sliderElement).slider('option', 'max', max);
          $(sliderElement).on('slidestop', (e, ui) => {
            onChange(ui.value);
          });
          $(sliderElement).slider('enable');
        },
        setPosition: function(frameNumber) {
          $(sliderElement).slider('option', 'value', frameNumber);
        },
        reset: function() {
          $(sliderElement).slider({disabled: true});
        }
      };
      slider.reset();

      let player = {
        currentFrame: 0,
        isPlaying: false,
        isReady: false,
        timeout: null,

        initialize: function() {
          this.currentFrame = 0;
          this.isPlaying = false;
          this.isReady = false;

          playButton.disabled = true;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
        },

        ready: function() {
          this.isReady = true;

          playButton.disabled = false;
        },

        seek: function(frameNumber) {
          if (!this.isReady) {
            return;
          }

          this.pause();

          if (frameNumber >= 0 && frameNumber < framesManager.frames.totalFrames()) {
            this.drawFrame(frameNumber);
            this.currentFrame = frameNumber;
          }
        },

        play: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = true;

          playButton.disabled = true;
          playButton.style.display = 'none';
          pauseButton.disabled = false;
          pauseButton.style.display = 'block';

          this.nextFrame();
        },

        pause: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = false;
          if (this.timeout != null) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }

          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
          playButton.disabled = false;
          playButton.style.display = 'block';
        },

        toogle: function() {
          if (!this.isPlaying) {
            this.play();
          } else {
            this.pause();
          }
        },

        nextFrame: function() {
          if (!this.isPlaying) {
            return;
          }

          if (this.currentFrame >= framesManager.frames.totalFrames()) {
            this.done();
            return;
          }

          this.drawFrame(this.currentFrame).then(() => {
            this.currentFrame++;
            this.timeout = setTimeout(() => this.nextFrame(), 1000 / (config.fps * parseFloat(speedInput.value)));
          });
        },

        drawFrame: function(frameNumber) {
          return new Promise((resolve, _) => {
            annotatedObjectsTracker.getFrameWithObjects(frameNumber).then((frameWithObjects) => {
              ctx.drawImage(frameWithObjects.img, 0, 0);

              for (let i = 0; i < frameWithObjects.objects.length; i++) {
                let object = frameWithObjects.objects[i];
                let annotatedObject = object.annotatedObject;
                let annotatedFrame = object.annotatedFrame;
                if (annotatedFrame.isInitialized()) {
                  annotatedObject.dom.style.display = 'block';
                  annotatedObject.dom.style.width = annotatedFrame.bbox.width + 'px';
                  annotatedObject.dom.style.height = annotatedFrame.bbox.height + 'px';
                  annotatedObject.dom.style.left = annotatedFrame.bbox.x + 'px';
                  annotatedObject.dom.style.top = annotatedFrame.bbox.y + 'px';
                } else {
                  annotatedObject.dom.style.display = 'none';
                }
              }

              slider.setPosition(this.currentFrame);

              resolve();
            });
          });
        },

        done: function() {
          this.currentFrame = 0;
          this.isPlaying = false;

          playButton.disabled = false;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
        }
      };

      function playClicked() {
        player.play();
      }

      function pauseClicked() {
        player.pause();
      }

      function initializeCanvasDimensions(img) {
        doodle.style.width = img.width + 'px';
        doodle.style.height = img.height + 'px';
        canvas.width = img.width;
        canvas.height = img.height;
        sliderElement.style.width = img.width + 'px';
      }

      function updateTranscriptionMap() {
        if (this.files.length != 1) {
          return;
        }

        var reader = new FileReader();
        reader.onload = (e) => {
          if (e.target.readyState != 2) {
            return;
          }

          if (e.target.error) {
            throw 'file reader error';
          }

          transcriptionMap = new Map();
          let transcriptions = JSON.parse(e.target.result);
          for(const videoFile in transcriptions){
            let zipFilename = transcriptions[videoFile].frames_zip_filename;
            let transcription = transcriptions[videoFile].transcription;
            transcriptionMap.set(zipFilename, transcription);
          }
        };
        reader.readAsText(this.files[0]);
      }

      function extractionFileUploaded() {
        if (this.files.length != 1) {
          return;
        }

        transcriptionsFile.disabled = true;
        zipFile.disabled = true;
        jsonFile.disabled = true;
        generateJSONButton.disabled = true;
        spacialRelationshipDiv.hidden = true;
        transcriptionDiv.hidden = true;
        resetAllAnnotatedObjects();
        slider.reset();
        player.initialize();

        let promise = extractFramesFromZip(config, this.files[0]);

        promise.then((frames) => {
          extractionProgressElement.innerHTML = 'Extraction completed. ' + frames.totalFrames() + ' frames captured.';
          if (frames.totalFrames() > 0) {
            frames.getFrame(0).then((blob) => {
              blobToImage(blob).then((img) => {
                initializeCanvasDimensions(img);
                ctx.drawImage(img, 0, 0);
                videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + img.width + 'x' + img.height;

                framesManager.set(frames);
                slider.init(
                  0,
                  framesManager.frames.totalFrames() - 1,
                  (frameNumber) => player.seek(frameNumber)
                );
                player.ready();

                jsonFile.disabled = false;
                playButton.disabled = false;
                generateJSONButton.disabled = false;
                spacialRelationshipDiv.hidden = false;
                transcriptionDiv.hidden = false;
              });
            });
          }

          transcriptionsFile.disabled = false;
          zipFile.disabled = false;
          let zipFilename = this.files[0].name;
          if(transcriptionMap.has(zipFilename)){
            transcriptionInput.value = transcriptionMap.get(zipFilename);
          }
        });
      }

      function interactify(dom, onChange) {
        let bbox = $(dom);
        bbox.addClass('bbox');

        let createHandleDiv = (className) => {
          let handle = document.createElement('div');
          handle.className = className;
          bbox.append(handle);
          return handle;
        };

        bbox.resizable({
          containment: 'parent',
          handles: {
            n: createHandleDiv('ui-resizable-handle ui-resizable-n'),
            s: createHandleDiv('ui-resizable-handle ui-resizable-s'),
            e: createHandleDiv('ui-resizable-handle ui-resizable-e'),
            w: createHandleDiv('ui-resizable-handle ui-resizable-w')
          },
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });

        bbox.draggable({
          containment: 'parent',
          handle: createHandleDiv('handle center-drag'),
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });
      }

      let mouse = {
        x: 0,
        y: 0,
        startX: 0,
        startY: 0
      };

      let tmpAnnotatedObject = null;

      doodle.onmousemove = function (e) {
        let ev = e || window.event;
        if (ev.pageX) {
          mouse.x = ev.pageX;
          mouse.y = ev.pageY;
        } else if (ev.clientX) {
          mouse.x = ev.clientX;
          mouse.y = ev.clientY;
        }
        mouse.x -= doodle.offsetLeft;
        mouse.y -= doodle.offsetTop;

        if (tmpAnnotatedObject !== null) {
          tmpAnnotatedObject.width = Math.abs(mouse.x - mouse.startX);
          tmpAnnotatedObject.height = Math.abs(mouse.y - mouse.startY);
          tmpAnnotatedObject.x = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
          tmpAnnotatedObject.y = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

          tmpAnnotatedObject.dom.style.width = tmpAnnotatedObject.width + 'px';
          tmpAnnotatedObject.dom.style.height = tmpAnnotatedObject.height + 'px';
          tmpAnnotatedObject.dom.style.left = tmpAnnotatedObject.x + 'px';
          tmpAnnotatedObject.dom.style.top = tmpAnnotatedObject.y + 'px';
        }

        mouseIsOnDoodle = true;
      }

      doodle.addEventListener("mouseenter", function() {mouseIsOnDoodle = true;}); 
      doodle.addEventListener("mouseout", function() {mouseIsOnDoodle = false;}); 
      doodle.onclick = function (e) {
        if (doodle.style.cursor != 'crosshair') {
          return;
        }

        if (tmpAnnotatedObject != null) {
          if(annotatedObjectsTracker.currentlyAnnotating != null){
            let annotatedObject = annotatedObjectsTracker.currentlyAnnotating;
            if(annotatedObject.dom !== null){
              doodle.removeChild(annotatedObject.dom);
            }
            annotatedObject.dom = tmpAnnotatedObject.dom;
            let bbox = new BoundingBox(tmpAnnotatedObject.x, tmpAnnotatedObject.y, tmpAnnotatedObject.width, tmpAnnotatedObject.height);
            annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));

            interactify(
              annotatedObject.dom,
              (x, y, width, height) => {
                let bbox = new BoundingBox(x, y, width, height);
                annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
              }
            );
          }
          tmpAnnotatedObject = null;
          doodle.style.cursor = 'default';
        } else {
          mouse.startX = mouse.x;
          mouse.startY = mouse.y;

          let dom = newBboxElement();
          dom.style.left = mouse.x + 'px';
          dom.style.top = mouse.y + 'px';
          if(annotatedObjectsTracker.currentlyAnnotating.id == 'target'){
            dom.style.border = '2px solid rgba(0, 255, 0, 1)';
          }
          else{
            dom.style.border = '2px solid rgba(255, 0, 0, 1)';
          }
          tmpAnnotatedObject = { dom: dom };
        }
      }

      // Keyboard shortcuts
      window.onkeydown = function(e) {
        let preventDefault = true;

        if(e.keyCode === 16 || e.keyCode === 17){
          controlOrShiftPressed = true;
        }
        if(controlOrShiftPressed){
          preventDefault = false;          
        }
        else{
          if (e.keyCode === 32 && mouseIsOnDoodle) { // space
            player.toogle();
          } else if(e.keyCode === 84 && mouseIsOnDoodle){ // T
            doodle.style.cursor = 'crosshair';
            annotatedObjectsTracker.currentlyAnnotating = annotatedObjectsTracker.getAnnotatedObjectByID('target');
          } else if(e.keyCode === 82 && mouseIsOnDoodle){ // R
            doodle.style.cursor = 'crosshair';
            annotatedObjectsTracker.currentlyAnnotating = annotatedObjectsTracker.getAnnotatedObjectByID('reference');
          } else if (e.keyCode === 27) { // escape
            if (tmpAnnotatedObject != null) {
              doodle.removeChild(tmpAnnotatedObject.dom);
              tmpAnnotatedObject = null;
            }
            annotatedObjectsTracker.currentlyAnnotating = null;
            doodle.style.cursor = 'default';
          } else if (e.keyCode == 37 && mouseIsOnDoodle) { // left
            player.seek(player.currentFrame - 1);
          } else if (e.keyCode == 39 && mouseIsOnDoodle) { // right
            player.seek(player.currentFrame + 1);
          } else {
            preventDefault = false;
          }
        }

        if (preventDefault) {
          e.preventDefault();
        }
      };

      window.onkeyup = function(e) {
        if(e.keyCode === 16 || e.keyCode === 17){
          controlOrShiftPressed = false;
        }
      }
    </script>
  </body>
</html>
